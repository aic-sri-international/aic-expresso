tree grammar AntlrGrinderOutputWalker;

options {

    // Default language but name it anyway
    //
    language  = Java;

    // Use the vocabulary generated by the accompanying
    // lexer. Maven knows how to work out the relationship
    // between the lexer and parser and will build the 
    // lexer before the parser. It will also rebuild the
    // parser if the lexer changes.
    //
    tokenVocab = AntlrGrinderParser;
    
    ASTLabelType = CommonTree;
    
    backtrack = true;
    memoize = true;
}

@header {

    package com.sri.ai.grinder.parser.antlr;

    import java.util.ArrayList;

    import com.sri.ai.expresso.api.Expression;
    import com.sri.ai.expresso.core.DefaultSymbol;
    import com.sri.ai.expresso.helper.Expressions;
}

@members {
/** Makes parser fail on first error. */
//@Override
//protected void mismatch(IntStream input, int ttype, BitSet follow)
//    throws RecognitionException {
//    throw new MismatchedTokenException(ttype, input);
//}

/** Makes parser fail on first error. */
//@Override
//public Object recoverFromMismatchedSet(IntStream input, RecognitionException e, BitSet follow)
//    throws RecognitionException {
//    throw e;
//    //return null;
//}

/** Makes parser fail on first error. */
//@Override
//protected Object recoverFromMismatchedToken(IntStream input, int ttype, BitSet follow)
//    throws RecognitionException {
//    throw new MismatchedTokenException(ttype, input);
//}

}

// Alter code generation so catch-clauses get replace with this action.
//@rulecatch {
//catch (RecognitionException e) { throw e; }
//}


/*
    The ANTLR output tree walker is the final step in parsing the LPI grammar.
    The walker converts the AST from ANTLR's native CommonTree node type to
    the expected Expression output.  It walks
    the CommonTree AST and at every node, generates the appropriate output
    node object.

    Adding new grammar rules
    ------------------------
    Add a converter under the expr rule to handle the new node types for the 
    new rules.  Make sure the children of the node types are declared as expr
    to ensure that the walker will invoke the expr rule on all the children.
*/
start returns [Expression value]
    : a=expr EOF { $value = a; }
    ;

expr returns [Expression value]
@init {
    ArrayList<Expression> varargs = new ArrayList<Expression>();
}
    : ^(PREVIOUSMESSAGETO a=expr b=expr)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("previous message to . from .", a, b); }
    | ^(MESSAGETO a=expr b=expr)                          { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("message to . from .", a, b); }
    | ^(SINGLE_ARROW a=expr b =expr)                      { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("->", a, b); }
    | ^(LAMBDA a=expr b=expr)                             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("lambda . : .", a, b); }
    | ^(IFTHENELSE a=expr b=expr c=expr)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("if . then . else .", a, b, c); }
    | ^(FORALL a=expr b=expr)                             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("for all . : .", a, b); }
    | ^(THEREEXISTS a=expr b=expr)                        { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("there exists . : .", a, b); }
    | ^(ARROW (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("=>", varargs); }
    | ^(DOUBLE_ARROW (a=expr {varargs.add(a); })*)        { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("<=>", varargs); }
    | ^(OR (a=expr {varargs.add(a); })*)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("or", varargs); }
    | ^(AND (a=expr {varargs.add(a); })*)                 { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("and", varargs); }
    | ^(IS (a=expr {varargs.add(a); })*)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("is", varargs); }
    | ^(EQUAL (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("=", varargs); }
    | ^(NOT_EQUAL (a=expr {varargs.add(a); })*)           { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("!=", varargs); }
    | ^(GREATER_THAN (a=expr {varargs.add(a); })*)        { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees(">", varargs); }
    | ^(GREATER_THAN_EQUAL (a=expr {varargs.add(a); })*)  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees(">=", varargs); }
    | ^(LESS_THAN (a=expr {varargs.add(a); })*)           { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("<", varargs); }
    | ^(LESS_THAN_EQUAL (a=expr {varargs.add(a); })*)     { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("<=", varargs); }
    | ^(IN (a=expr {varargs.add(a); })*)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("in", varargs); }
    | ^(UNION (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("union", varargs); }
    | ^(INTERSECTION (a=expr {varargs.add(a); })*)        { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("intersection", varargs); }
    | ^(PLUS (a=expr {varargs.add(a); })*)                { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("+", varargs); }
    | ^(DASH (a=expr {varargs.add(a); })*)                { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("-", varargs); }
    | ^(MINUS (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("minus", varargs); }
    | ^(TIMES (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("*", varargs); }
    | ^(DIVIDE (a=expr {varargs.add(a); })*)              { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("/", varargs); }
    | ^(CARAT (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("^", varargs); }
//    | ^(MINUS a=expr)                                     { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("-", a); }
    | ^(NOT (a=expr {varargs.add(a); })*)                 { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("not", varargs); }
    | ^(CASE (a=expr {varargs.add(a); })*)                { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("case", varargs); }
    | ^(INDEX (a=expr {varargs.add(a); })*)               { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("index of . in .", varargs); }
    | ^(OCCURS (a=expr {varargs.add(a); })*)              { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("occurs in", varargs); }
    | ^(UNDERSCORESET (a=expr {varargs.add(a); })*)       { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees(". _{ . : . }", varargs); }
    | ^(UNDERSCORE (a=expr {varargs.add(a); })*)          { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("_", varargs); }
    | ^(NEIGHBORSOF a=expr b=expr)                        { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("neighbors of . from .", a, b); }
    | ^(NEIGHBORSOFVARIABLE a=expr)                       { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("neighbors of variable", a); }
    | ^(NEIGHBORSOFFACTOR a=expr)                         { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("neighbors of factor", a); }
    | ^(VALUEOF a=expr)                                   { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("value of", a); }
    | ^(SQUAREBRACKET a=expr)                             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("[ . ]", a); }
    | ^(SET a=expr)                                       { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{ . }", a); }
    | ^(SETCOMPREHENSION1 a=expr b=expr)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{ . . . }", a, b, null); }
    | ^(SETCOMPREHENSION2 a=expr b=expr c=expr)           { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{ . . . }", a, b, c); }
    | ^(SETCOMPREHENSION3 a=expr b=expr)                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{ . . . }", null, a, b); }
    | ^(MULTISET a=expr)                                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{{ . }}", a); }
    | ^(MULTISETCOMPREHENSION1 a=expr b=expr)             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{{ . . . }}", a, b, null); }
    | ^(MULTISETCOMPREHENSION2 a=expr b=expr c=expr)      { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{{ . . . }}", a, b, c); }
    | ^(MULTISETCOMPREHENSION3 a=expr b=expr)             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("{{ . . . }}", null, a, b); }
    | ^(SEQUENCE a=expr)                                  { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("| . |", a); }
    | ^(TUPLE a=expr)                                     { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("( . )", a); }
    | ^(FUNCTION a=expr (b=expr {varargs.add(b); })*)     { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees(a, varargs); }
    | ^(SYMBOL ID)                                        { $value = DefaultSymbol.createSymbol($ID.text); }
    | ^(SYMBOL_EXPRESSION a=expr)                         { $value = DefaultSymbol.createSymbol(a); }
    | ^(KLEENE (a=expr { varargs.add(a); })*)             { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("kleene list", varargs); }
    | ^(COMPREHENSION_ON a=expr)                          { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("( on . )", a); }
    | ^(COMPREHENSION_VERT_BAR a=expr)                    { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees("|", a); }
    | ^(COLON a=expr b=expr)                              { $value = Expressions.makeExpressionBasedOnSyntaxTreeWithLabelAndSubTrees(":", a, b); }
    ;


