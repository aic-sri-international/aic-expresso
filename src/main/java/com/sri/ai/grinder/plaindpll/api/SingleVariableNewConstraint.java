/*
 * Copyright (c) 2013, SRI International
 * All rights reserved.
 * Licensed under the The BSD 3-Clause License;
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 * http://opensource.org/licenses/BSD-3-Clause
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 * 
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * Neither the name of the aic-expresso nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, 
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.sri.ai.grinder.plaindpll.api;

import java.util.Collection;

import com.sri.ai.expresso.api.Expression;
import com.sri.ai.grinder.api.RewritingProcess;

/**
 * An {@link Expression} with efficient internal representation for incrementally deciding satisfiability of a boolean formulas on literals in a certain theory.
 * 
 * @author braz
 *
 */
public interface SingleVariableNewConstraint extends Expression {

	/**
	 * Returns the {@link ConstraintTheory} for this constraint.
	 * @return the constraint theory.
	 */
	NewConstraintTheory getConstraintTheory();
	
	/**
	 * @return the variable term constrained by this constraint.
	 */
	Expression getVariable();
	
	/**
	 * Returns the type of the variable.
	 */
	Expression getVariableDomain(RewritingProcess process);

	/**
	 * Returns the variable domain size, if determined, or -1 otherwise.
	 * @param process
	 * @return
	 */
	long getVariableDomainSize(RewritingProcess process);

	/**
	 * Returns the literals that are part of this constraint, but not defined on the variable.
	 * @return
	 */
	Collection<Expression> getExternalLiterals();

	/**
	 * Returns an {@link ConstraintTheoryTester} representing a constraint equivalent to this one given that 'externalLiteral' is true.
	 * For example, <code>x != 3 and y = 3</code> is equivalent to <code>x != 3</code> under <code>y = 3</code>.
	 * While this method could in principle be defined for literals that are not external,
	 * that is, literals on the variable of this single-variable constraint,
	 * that would imply the literal being applied being kept somewhere else,
	 * which is inadvisable because all literals on the same variables should eventually be kept in the same place.
	 * <p>
	 * If the external literal is a splitter generated by this constraint, and that literal cannot be looked easily from the contextual constraint,
	 * then this method must transform the constraint in such a way that it will not be picked anymore,
	 * in order to avoid infinite picking of the same splitter.
	 * 
	 * @param literal a literal assumed to be true
	 * @param process the rewriting process
	 * @return a constraint equivalent to this one given the literal
	 */
	SingleVariableNewConstraint simplifyGiven(Expression externalLiteral, RewritingProcess process);
	
	/**
	 * Returns an {@link ConstraintTheoryTester} representing the conjunction of this constraint and a given literal,
	 * or null if they are contradictory.
	 * @param literal the literal
	 * @param process the rewriting process
	 * @return the application result or <code>null</code> if contradiction.
	 */
	SingleVariableNewConstraint conjoin(Expression literal, RewritingProcess process);
	
	/**
	 * Picks a splitter whose value is necessary in order to determine the model count of the constraint.
	 * 
	 * The representation must be chosen such that a splitter is either no longer generated after an application of {@link #simplifyGiven(Expression, RewritingProcess)}
	 * with it or its negation, or no longer generated if the contextual constraint can be used to check whether it is valid or not.
	 * This avoids infinite picking of the same splitter.
	 * 
	 * @param process the current rewriting process
	 * @return the splitter
	 */
	Expression pickSplitter(RewritingProcess process);
	
	/**
	 * The number of assignments to the variable that satisfies the constraint.
	 * @param process the current rewriting process
	 * @return an expression representing the model count
	 */
	Expression modelCount(RewritingProcess process);
	
	String debuggingDescription(RewritingProcess process);
}